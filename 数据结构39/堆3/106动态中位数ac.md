### 题目描述

依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。

输入格式
第一行输入一个整数  P ，代表后面数据集的个数，接下来若干行输入各个数据集。
每个数据集的第一行首先输入一个代表数据集的编号的整数。
然后输入一个整数  M ，代表数据集中包含数据的个数， M  一定为奇数，数据之间用空格隔开。
数据集的剩余行由数据集的数据构成，每行包含  10  个数据，最后一行数据量可能少于  10  个，数据之间用空格隔开。

输出格式
对于每个数据集，第一行输出两个整数，分别代表数据集的编号以及输出中位数的个数（应为数据个数加一的二分之一），数据之间用空格隔开。
数据集的剩余行由输出的中位数构成，每行包含  10  个数据，最后一行数据量可能少于  10  个，数据之间用空格隔开。
输出中不应该存在空行。

数据范围
1≤P≤1000 ,
1≤M≤9999

### 样例

Input

```
3 
1 9 
1 2 3 4 5 6 7 8 9 
2 9 
9 8 7 6 5 4 3 2 1 
3 23 
23 41 13 22 -3 24 -31 -11 -8 -7 
3 5 103 211 -311 -45 -67 -73 -81 -99 
-33 24 56
```

Output

```
1 5
1 2 3 4 5
2 5
9 8 7 6 5
3 12
23 23 22 22 13 3 5 5 3 -3 
-7 -3
```

----------

### 算法
#### DS-堆

直觉：二分插入排序$log10000 \times 10000 \times 1000$（好像也可以过。。。试了别人的代码80ms）

考虑将一个待找中位数的序列分成两部分，前$\frac{n}{2}$部分用大根堆来维护，后$\frac{n + 1}{2}$部分用小根堆来维护，每次输出小根堆的堆顶。
除了第一个元素外，另外的元素两两分成一组，每次直接把两个元素插入小根堆，再把小根堆堆顶取出插入大根堆。如果此时小根堆堆顶小于大根堆堆顶，再交换它们。。
每组最多耗时$5 \times log(\frac{n}{2})$加一次比较。

如果每次都比较再决定插入哪个堆：耗时$3 \times log(\frac{n}{2})$加三次比较。

这个题麻烦在输入输出。。。。

#### 时间复杂度

$O(p \times m logm)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 10010;

int n, idx;

void print(int x) {
    printf("%d ", x);
    ++idx;
    if (idx % 10 == 0) puts("");
}

int main() {
    int cases;
    scanf("%d", &cases);
    while (cases--) {
        priority_queue<int, vector<int>, greater<int> > h2; //没有clear函数
        priority_queue<int> h1;
        idx = 0;
        int t;
        scanf("%d%d", &t, &n);printf("%d %d\n", t, (n + 1) / 2);
        scanf("%d", &t);
        h2.push(t);
        print(t);
        for (int i = 0; i < n / 2; i++) {
            int t1, t2;
            scanf("%d%d", &t1, &t2);
            h2.push(t1), h2.push(t2);
            t1 = h2.top(), h2.pop();
            h1.push(t1);
            if (h2.top() < h1.top()) {
                t1 = h2.top(), h2.pop();
                t2 = h1.top(), h1.pop();
                h1.push(t1), h2.push(t2);
            }
            print(h2.top());
        }
        if (idx % 10 != 0) puts("");
    }
    return 0;
}
```