### 题目描述

给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。

输入格式
第一行包含整数N，表示数列长度。
第二行包含N个整数，表示整数数列。

输出格式
共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。

数据范围
1≤N≤10^5 
1≤数列中元素≤10^9 

### 样例

Input

```
5
3 4 2 7 5
```

Output

```
-1 3 -1 2 2
```

----------

### 算法
#### 单调栈

从左至右依次遍历每一个数，对于遍历的这个数$a[x]$而言，考虑是否加入栈中，如果它比刚刚入栈的数$a[x - 1]$要小，那么$a[x - 1]$就没有在栈中的必要，因为对于下一个要遍历的数$a[x + 1]$而言，$a[x]$显然比$a[x - 1]$要更优。故栈底到栈顶单调递增。

#### 时间复杂度

每个数最多入栈一次，出栈一次。
$O(n)$

#### 参考文献

#### C++ 代码

``` cpp
//100ms，若用cin，cout耗时800ms+
#include <cstdio>
const int N = 100010;

int stk[N], tt = -1;

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i< n; i++) {
        int t;
        scanf("%d", &t);
        while (tt >= 0 && stk[tt] >= t) tt--;
        if (tt >= 0) printf("%d ", stk[tt]);
        else printf("-1 ");
        stk[++tt] = t;
    }
    return 0;
}
```