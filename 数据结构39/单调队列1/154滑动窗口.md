### 题目描述

给定一个大小为  n≤106  的数组。
有一个大小为  k  的滑动窗口，它从数组的最左边移动到最右边。
你只能在窗口中看到  k  个数字。
每次滑动窗口向右移动一个位置。
以下是一个例子：
该数组为 [1 3 -1 -3 5 3 6 7]， k  为  3 。
窗口位置	最小值	最大值
[1 3 -1] -3 5 3 6 7	-1	3
1 [3 -1 -3] 5 3 6 7	-3	3
1 3 [-1 -3 5] 3 6 7	-3	5
1 3 -1 [-3 5 3] 6 7	-3	5
1 3 -1 -3 [5 3 6] 7	3	6
1 3 -1 -3 5 [3 6 7]	3	7
你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

输入格式
输入包含两行。
第一行包含两个整数  n  和  k ，分别代表数组长度和滑动窗口的长度。
第二行有  n  个整数，代表数组的具体数值。
同行数据之间用空格隔开。

输出格式
输出包含两个。
第一行输出，从左至右，每个位置滑动窗口中的最小值。
第二行输出，从左至右，每个位置滑动窗口中的最大值。

### 样例

Input

```
8 3
1 3 -1 -3 5 3 6 7
```

Output

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```

----------

### 算法
#### 单调队列

求滑动窗口中最大值，单调队列递减。
求滑动窗口最小值，单调队列递增。
为了控制队列中元素都在窗口内，队列中应该存数组下标。
输入输出太多，用`scanf`，`printf`。

#### 时间复杂度

每个元素最多入对一次，出队一次。$O(n)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>

const int N = 1000010;

int n, k, a[N];
int que[N], hh, tt = -1;

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    for (int i = 0; i < n; i++) {
        if (hh <= tt && i - que[hh] >= k) hh++;
        while (hh <= tt && a[que[tt]] >= a[i]) tt--; //注意是a[que[tt]]，不是que[tt]
        que[++tt] = i;
        if (i >= k - 1) printf("%d ", a[que[hh]]);
    }
    puts("");
    hh = 0, tt = -1;
    for (int i = 0; i < n; i++) {
        if (hh <= tt && i - que[hh] >= k) hh++;
        while (hh <= tt && a[que[tt]] <= a[i]) tt--;
        que[++tt] = i;
        if (i >= k - 1) printf("%d ", a[que[hh]]);
    }
    return 0;
}
```