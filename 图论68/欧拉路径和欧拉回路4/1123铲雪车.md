### 题目描述

随着白天越来越短夜晚越来越长，我们不得不考虑铲雪问题了。
整个城市所有的道路都是双向车道,道路的两个方向均需要铲雪。因为城市预算的削减，整个城市只有 1 辆铲雪车。
铲雪车只能把它开过的地方（车道）的雪铲干净，无论哪儿有雪，铲雪车都得从停放的地方出发，游历整个城市的街道。
现在的问题是：最少要花多少时间去铲掉所有道路上的雪呢？

输入格式
输入数据的第  1  行表示铲雪车的停放坐标  (x,y) ， x,y  为整数，单位为米。
下面最多有4000行，每行给出了一条街道的起点坐标和终点坐标，坐标均为整数，所有街道都是笔直的，且都是双向车道。
铲雪车可以在任意交叉口、或任何街道的末尾任意转向，包括转  U  型弯。
铲雪车铲雪时前进速度为  20  千米/时，不铲雪时前进速度为  50  千米/时。
保证：铲雪车从起点一定可以到达任何街道。

输出格式
输出铲掉所有街道上的雪并且返回出发点的最短时间，精确到分钟，四舍五入到整数。
输出格式为”hours:minutes”，minutes不足两位数时需要补前导零。
具体格式参照样例。

数据范围
−10^6≤x,y≤10^6 
所有位置坐标绝对值不超过  10^6 。

### 样例

Input

```
0 0
0 0 10000 10000
5000 -10000 5000 10000
5000 10000 10000 10000
```

Output

```
3:55
```

#### 样例解释
输出结果表示共需3小时55分钟。

----------

### 算法
#### 欧拉回路

由哥尼斯堡 七桥问题引申而来。

对于连通图：
欧拉路径（小学数奥一笔画问题）：每条边走一次
（无向图充要条件）除了起点和终点的度数为奇数，其他结点的度数需要为偶数；~~或者所有结点度数为偶数~~。
（有向图充要条件）起点的出度比入度多一，终点的入度比出度多一，其余点出度等于入度。
欧拉回路：每条边走一次，且回到起始点
（无向图充要条件）所有结点度数为偶数。
（有向图充要条件）所有结点的出度等于入度。

必要性：通过发掘欧拉路径/回路的性质。
充分性：构造一种路径，使其为欧拉路径/回路。

如何构造：**环和路径，环和环可以融合**。按照dfs从起点走到终点，回溯的时候可能产生一些环，融合即可。

伪代码：
```
仔细想想路径是怎么走的。。。
//用边判重 邻接表O(m ^ 2) 邻接矩阵O(nm)
//考虑一个结点，有m条自环的情况
//优化：用一条边，删一条边 O(m)
dfs(u) {
	for 从u出发的所有边 //若为无向图，正边走完后，反边要置为无效！
		dfs() //扩展
	seq <- u;
}
```

再看本题：考虑为有向图，每个结点的入度等于出度，存在欧拉回路。所以直接求所有边的总长度就可以了。。

#### 时间复杂度

$O(m)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cmath>
#include <iostream>

using namespace std;

int x1, _y1, x2, y2;
double res;

int main() {
    cin >> x1 >> _y1;
    while (cin >> x1 >> _y1 >> x2 >> y2) {
        res += sqrt(pow(x1 - x2, 2) + pow(_y1 - y2, 2));        
    }
    res *= 2;
    int m = (res * 60 / 20000 + 0.5); //int m = round(res * 60 / 20 / 1000);
    printf("%d:%02d\n", m / 60, m % 60);
    return 0;
}
```