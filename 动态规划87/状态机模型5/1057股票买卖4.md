### 题目描述

给定一个长度为  N  的数组，数组中的第  i  个数字表示一个给定股票在第  i  天的价格。
设计一个算法来计算你所能获取的最大利润，你最多可以完成  k  笔交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。一次买入卖出合为一笔交易。

输入格式
第一行包含整数  N  和  k ，表示数组的长度以及你可以完成的最大交易数量。

第二行包含  N  个不超过  10000  的正整数，表示完整的数组。

输出格式
输出一个整数，表示最大利润。

数据范围
1≤N≤10…^5 ,
1≤k≤100

### 样例

Input1

```
3 2
2 4 1
```

Output1

```
2
```

Input2

```
6 2
3 2 6 5 0 3
```

Output2

```
7
```

### 样例解释

样例1：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

样例2：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。共计利润 4+3 = 7.

----------

### 算法
#### 状态机模型dp

状态：$f[i][j][0]$表示前$i$天中，已经完成第$j$次交易，不持有股票时的最大利润。
$f[i][j][1]$表示前$i$天中，开始第$j$次交易，持有股票时的最大利润。

转移：$f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1]  + w[i])$
$f[i][j][1] = max(f[i - 1][j - 1][0] - w[i], f[i - 1][j][1])$

**初始化1**：

``` cpp
//980ms
memset(f, -0x3f, sizeof f);
for (int i = 0; i <= n; i++) f[i][0][0] = 0
```

答案：
``` cpp
int res = 0;
for (int i = 0; i <= k; i++)
	res = max(res, f[n][i][0]);
print("%d\n", res);
```

**初始化2**：
``` cpp
// 600ms
for (int i = 0; i <= k; i++)
        f[0][i][1] = -0x3f3f3f3f;
        
// 1000ms
/*memset(f, -0x3f, sizeof f);
for (int i = 0; i <= n; i++)
	for (int j = 0; j <= k; j++)
		f[i][j][0] = 0;*/
```

答案：$max(f[n][k][0])$

#### 时间复杂度

$O(n \times k)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 100010, K = 110;

int f[N][K][2];
int k, n;

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 0; i <= k; i++) f[0][i][1] = -0x3f3f3f;
    for (int i = 1; i <= n; i++) {
        int w;
        scanf("%d", &w);
        for (int j = 1; j <= k; j++) {
            f[i][j][0] = max(f[i - 1][j][1] + w, f[i - 1][j][0]);
            f[i][j][1] = max(f[i - 1][j - 1][0] - w, f[i - 1][j][1]);
        }
    }
    printf("%d\n", f[n][k][0]);
    return 0;
}
```