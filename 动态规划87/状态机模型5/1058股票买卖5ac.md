### 题目描述

给定一个长度为  N  的数组，数组中的第  i  个数字表示一个给定股票在第  i  天的价格。
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即**冷冻期为  1  天**)。

输入格式
第一行包含整数  N ，表示数组长度。
第二行包含  N  个不超过  10000  的正整数，表示完整的数组。

输出格式
输出一个整数，表示最大利润。

数据范围
1≤N≤10^5

### 样例

Input

```
5
1 2 3 0 2
```

Output

```
3
```

#### 样例解释
对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]，第一笔交易可得利润 2-1 = 1，第二笔交易可得利润 2-0 = 2，共得利润 1+2 = 3。

----------

### 算法
#### 状态机模型dp

股票每天的价格存储在数组$c[]$中。
状态：$f[i][0]$表示在第$i$天时不持有股票时的最大利润，$f[i][1]$表示在第$i$天持有股票时的最大利润。
转移：$f[i][0] = max\{f[i - 1][0], f[i - 1][1] + c[i] \}, f[i][1] = max\{f[i - 1][1], f[i - 2][0] - c[i]\},(i >= 2)$
$if:i == 1,f[i][1] = -c[i]$
初始化：$f[0][0] = 0, f[0][1] = -inf$
结果：$f[n][0]$

#### 时间复杂度

$O(n)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 100010;

int c[N], f[N][2];

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &c[i]);
    f[0][1] = -1e9, f[0][0] = 0, f[1][0] = 0, f[1][1] = -c[1];
    for (int i = 2; i <= n; i++) {
        f[i][0] = max(f[i - 1][0], f[i - 1][1] + c[i]);
        f[i][1] = max(f[i - 1][1], f[i - 2][0] - c[i]); //冷冻期一天
    }
    printf("%d\n", f[n][0]);
    return 0;
}
```