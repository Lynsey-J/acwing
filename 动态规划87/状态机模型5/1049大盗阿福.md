### 题目描述

阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。
这条街上一共有  N  家店铺，每家店中都有一些现金。
阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。
作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。
他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？

输入格式
输入的第一行是一个整数  T ，表示一共有  T  组数据。
接下来的每组数据，第一行是一个整数  N  ，表示一共有  N  家店铺。
第二行是  N  个被空格分开的正整数，表示每一家店铺中的现金数量。
每家店铺中的现金数量均不超过1000。

输出格式
对于每组数据，输出一行。
该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。

数据范围
1≤T≤50 ,
1≤N≤10^5

### 样例

Input

```
2
3
1 8 2
4
10 7 6 14
```

Output

```
8
24
```

### 样例解释
对于第一组样例，阿福选择第2家店铺行窃，获得的现金数量为8。
对于第二组样例，阿福选择第1和4家店铺行窃，获得的现金数量为10+14=24。

----------

### 算法
#### dp

法一（普通dp）：

状态$f[i]$表示前$i$家店铺，得到的最大现金数。
$f[i] = max(f[i] + f[i - 2], f[i - 1])$
初始化$f[i] = a[i]$，迭代从$f[2]$开始。
答案：$f[n]$

法二（状态机模型dp）：(感觉有点像`240食物链`的扩展域的思想)

状态$f[i][0]$表示前$i$个店铺，当不盗窃第$i$个店铺时获得的最大现金素；$f[i][1]$表示前$i$个店铺，盗窃第$i$个店铺时获得的最大现金数。

所有读入的数存在$f[i][1]$内
$f[i][0] = max(f[i - 1][1], f[i - 1][0])$
$f[i][1] += f[i - 1][0]$

#### 时间复杂度

$O(n)$

#### 参考文献

#### C++ 代码

``` cpp
//法一
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 100010;

int f[N];

int main() {
    int cases;
    scanf("%d", &cases);
    while (cases--) {
        int n;
        scanf("%d", &n);
        for (int i = 1; i <= n; i++)
            scanf("%d", &f[i]);
        for (int i = 2; i <= n; i++)
            f[i] = max(f[i] + f[i - 2], f[i - 1]);
        printf("%d\n", f[n]);
    }
    return 0;
}
```

``` cpp
//法二
#include <cstdio>
#include <iostream>

using namespace std;

const int N = 100010;

int f[N][2], n;

int main() {
    int cases;
    scanf("%d", &cases);
    while (cases--) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++)
            scanf("%d", &f[i][1]);
        for (int i = 1; i <= n; i++) {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] += f[i - 1][0];
        }
        printf("%d\n", max(f[n][1], f[n][0]));
    }
    return 0;
}
```