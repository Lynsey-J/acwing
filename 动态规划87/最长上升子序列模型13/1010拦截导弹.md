### 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。
但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。
某天，雷达捕捉到敌国的导弹来袭。
由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。
输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

输入格式
共一行，输入导弹依次飞来的高度。

输出格式
第一行包含一个整数，表示最多能拦截的导弹数。
第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。

数据范围
雷达给出的高度数据是不大于  30000  的正整数，导弹数不超过  1000 。

### 样例

Input

```
389 207 155 300 299 170 158 65
```

Output

```
6
2
```

----------

### 算法1
#### dp

问1：求最长不上升子序列。
问2：求最长不上升子序列的组数 = 求最长上升子序列。设最长上升子序列长度为$a$。
证明：很显然，最长上升子序列中的每一个导弹都需要一套各自的系统，$res \ge a$。
~~考查最长上升子序列中相邻元素$e_i, e_{i + 1}$，它们之间的元素要么$ \le e_i$，要么$\ge e_{i + 1}$，所以~~

https://www.acwing.com/solution/content/10173/

对于每一组最长不上升子序列的最后一个元素（该组不上升子序列的最小元素），按该元素升序排列（如果有相同的，完全可以把它们放到同一个组中），即构成一个上升子序列，则$res \le a$。

综上，$res = a$。

#### 时间复杂度

$O(n^2)$

### 算法2
#### 贪心
https://www.acwing.com/solution/content/10173/
`题目的第二问，对于第i号导弹，要么选择（大于等与i号导弹的）末尾导弹高度最小的拦截系统，要么新创一个拦截系统，用一个数字即每套拦截系统此时所拦截的最后一个（最小）导弹高度，来表示该系统。这样就得到了一个数组，数组最终长度就是所需最少拦截系统数目。`

这样一来，代码和`896最长上升子序列2`代码一样。。自然求的就是最长上升子序列，算法1得证。

#### 时间复杂度

$O(nlogn)$

#### 参考文献

#### C++ 代码

``` cpp
//算法1
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1010;

int a[N], f[N], n, res;

int main() {
    while (cin >> a[n + 1]) n++;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < i; j++)
            if (a[j] >= a[i])
                f[i] = max(f[i], f[j]);
        f[i]++;
        res = max(res, f[i]);
    }
    cout << res << endl;
    res = 0;
    memset(f, 0, sizeof f);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j < i; j++)
            if (a[j] < a[i])
                f[i] = max(f[i], f[j]);
        f[i]++;
        res = max(res, f[i]);
    }
    cout << res << endl;
    return 0;
}
```