### 题目描述

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。
小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。
小沐沐说，对于两个数列A和B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。
奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。
不过，只要告诉奶牛它的长度就可以了。
数列A和B的长度均不超过3000。

输入格式
第一行包含一个整数N，表示数列A，B的长度。
第二行包含N个整数，表示数列A。
第三行包含N个整数，表示数列B。

输出格式
输出一个整数，表示最长公共上升子序列的长度。

数据范围
1≤N≤3000 ,序列中的数字均不超过 2^31−1

### 样例

Input

```
4
2 2 1 3
2 1 2 3
```

Output

```
2
```

----------

### 算法
#### DP,线性DP,前缀和

yxc:https://www.acwing.com/solution/content/4955/

这道题目是`895最长上升子序列`和`897最长公共子序列`的结合版，在状态表示和状态计算上都是融合了这两道题目的方法。

状态表示：
- `f[i][j]`代表所有`a[1 ~ i]`和`b[1 ~ j]`中以`b[j]`结尾的公共上升子序列的集合；
- `f[i][j]`的值等于该集合的子序列中长度的最大值；

状态计算（对应集合划分）：
首先依据公共子序列中是否包含`a[i]`，将`f[i][j]`所代表的集合划分成两个不重不漏的子集：
- 不包含`a[i]`的子集，最大值是`f[i - 1][j]`；
- 包含`a[i]`的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在`b[]`中是哪个数：
	- 子序列只包含`b[j]`一个数，长度是1；
	- 子序列的倒数第二个数是`b[1]`的集合，最大长度是`f[i - 1][1] + 1`；
	- …
	- 子序列的倒数第二个数是`b[j - 1]`的集合，最大长度是`f[i - 1][j - 1] + 1`；

如果直接按上述思路实现，需要三重循环：
``` cpp
for (int i = 1; i <= n; i ++ ) {
    for (int j = 1; j <= n; j ++ ) {
        f[i][j] = f[i - 1][j];
        if (a[i] == b[j]) {
            int maxv = 1;
            for (int k = 1; k < j; k ++ )
                if (a[i] > b[k])
                    maxv = max(maxv, f[i - 1][k] + 1);
            f[i][j] = max(f[i][j], maxv);
        }
    }
}
```

然后我们发现每次循环求得的`maxv`是满足`a[i] > b[k]`的`f[i - 1][k] + 1`的前缀最大值。
因此可以直接将`maxv`提到第一层循环外面，减少重复计算，此时只剩下两重循环。
最终答案枚举子序列结尾取最大值即可。

#### 时间复杂度

代码中一共两重循环，因此时间复杂度是$O(n^2)$。

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 3010;

int f[N][N];
int n, a[N], b[N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    
    for (int i = 1; i <= n; i++) {
        int maxv = 0; //求maxv，优化为二重循环
        for (int j = 1; j <= n; j++) {
            f[i][j] = f[i - 1][j];
            if (a[i] == b[j]) f[i][j] = maxv + 1;
            if (a[i] > b[j]) maxv = max(maxv, f[i - 1][j]);
        }
    }
    int res = 0;
    for (int i = 1; i <= n; i++) res = max(res, f[n][i]);
    cout << res << endl;
    return 0;
}
```