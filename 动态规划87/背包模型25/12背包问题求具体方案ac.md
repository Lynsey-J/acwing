### 题目描述

有  N  件物品和一个容量是  V  的背包。每件物品只能使用一次。
第  i  件物品的体积是  vi ，价值是  wi 。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是  1…N 。

输入格式
第一行两个整数， N，V ，用空格隔开，分别表示物品数量和背包容积。
接下来有  N  行，每行两个整数  vi,wi ，用空格隔开，分别表示第  i  件物品的体积和价值。

输出格式
输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。
物品编号范围是  1…N 。

数据范围
0<N,V≤1000
0<vi,wi≤1000

### 样例

Input

```
4 5
1 2
2 4
3 4
4 6
```

Output

```
1 4
```

----------

### 算法
#### 01背包求具体方案

还没实现的直觉：

第一轮迭代从第$n$个物品开始。
维护$from$数组，表示添加了物品$from[i]$后得到$f[i]$的最优解。
~~从$f[v], f[v - 1], ...$开始，找到下标$j$使$f[j] == f[v]$且$f[j] > f[j - 1]$。~~
从$f[v], f[v - c[from[v]]], ...$一直到$f[x] = 0$结束找到所有物品。

yxc：

不优化空间，用$f[i][j]$记录最大价值。
为了方便输出结果，第一层循环从$n$至$1$遍历。
找构成最大价值的物品时，按从第$1$至第$n$个物品的顺序遍历，如果满足$f[i + 1][j - c[i]] + w[i] == f[i][j]$（$j \ge c[i]$），则该物品是构成最大价值的一员，更新：$j = j - c[i]$。

#### 时间复杂度

$O(n \times v)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1010, V = N;

int f[N][V], n, v, c[N], w[N];

int main() {
    cin >> n >> v;
    for (int i = 1; i <= n; i++)
        cin >> c[i] >> w[i];
    for (int i = n; i; i--)
        for (int j = 0; j <= v; j++)
            if (j < c[i]) f[i][j] = f[i + 1][j];
            else f[i][j] = max(f[i + 1][j], f[i + 1][j - c[i]] + w[i]);
    for (int i = 1, j = v; i <= n; i++)
        if (j >= c[i] && f[i + 1][j - c[i]] + w[i] == f[i][j]) {
            cout << i << ' ';
            j -= c[i];
        }
    return 0;
}
```