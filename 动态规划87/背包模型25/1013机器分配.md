### 题目描述

总公司拥有M台 相同 的高效设备，准备分给下属的N个分公司。
各分公司若获得这些设备，可以为国家提供一定的盈利。盈利与分配的设备数量有关。
问：如何分配这M台设备才能使国家得到的盈利最大？
求出最大盈利值。
分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数M。

输入格式
第一行有两个数，第一个数是分公司数N，第二个数是设备台数M；
接下来是一个N*M的矩阵，矩阵中的第 i 行第 j 列的整数表示第 i 个公司分配 j 台机器时的盈利。

输出格式
第一行输出最大盈利值；
接下N行，每行有2个数，即分公司编号和该分公司获得设备台数。
答案不唯一，输入任意合法方案即可。

数据范围
1≤N≤10 ,
1≤M≤15 

### 样例

Input

```
3 3
30 40 50
20 30 50
20 25 30
```

Output

```
70
1 1
2 1
3 1
```

----------

### 算法
#### 分组背包 + 求具体方案

直觉：(暴力枚举)。。。没尝试

设备总数为背包容量，每个公司视为一个物品组。
不进行空间优化，方便找到最优解的路径。

#### 时间复杂度

$O(n \times m^2)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 11, V = 16;

int f[N][V], n, v, w[N][V];

int main() {
    cin >> n >> v;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= v; j++)
            cin >> w[i][j];
    for (int i = 1; i <= n; i++)
        for (int j = v; j >= 0; j--)
            for (int k = 0; k <= j; k++) //k == 0时对应不选组内物品的情况，直接写在循环内了
                f[i][j] = max(f[i][j], f[i - 1][j - k] + w[i][k]);
    cout << f[n][v] << endl;
    for (int i = n, j = v; i; i--)
        for (int k = 0; k <= v; k++)
            if (f[i][j] - w[i][k] == f[i - 1][j - k]) {
                cout << i << ' ' << k << endl;
                j -= k;
                break;
            }
    
    return 0;
}
```