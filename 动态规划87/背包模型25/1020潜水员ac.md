### 题目描述

潜水员为了潜水要使用特殊的装备。
他有一个带2种气体的气缸：一个为氧气，一个为氮气。
让潜水员下潜的深度需要各种数量的氧和氮。
潜水员有一定数量的气缸。
每个气缸都有重量和气体容量。
潜水员为了完成他的工作需要特定数量的氧和氮。
他完成工作所需气缸的总重的最低限度的是多少？
例如：潜水员有5个气缸。每行三个数字为：氧，氮的（升）量和气缸的重量：

```
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119
```

如果潜水员需要5升的氧和60升的氮则总重最小为249（1，2或者4，5号气缸）。
你的任务就是计算潜水员为了完成他的工作需要的气缸的重量的最低值。

输入格式
第一行有2个整数  m，n 。它们表示氧，氮各自需要的量。
第二行为整数  k  表示气缸的个数。
此后的  k  行，每行包括 ai，bi，ci ，3个整数。这些各自是：第  i  个气缸里的氧和氮的容量及气缸重量。

输出格式
仅一行包含一个整数，为潜水员完成工作所需的气缸的重量总和的最低值。

数据范围
1≤m≤21 ,
1≤n≤79 ,
1≤k≤1000 ,
1≤ai≤21 ,
1≤bi≤79 ,
1≤ci≤800

### 样例

Input

```
5 60
5
3 36 120
10 25 129
5 50 250
1 45 130
4 20 119
```

Output

```
249
```

----------

### 算法
#### 二维费用背包，求最小值

状态：$f[i][j][k]$表示对于前$i$个气瓶，选择一些气瓶，氧气含量达到$j$，氮气含量达到$j$的最小总重量。
考虑第$i$个气瓶是否被选中。
转移：$f[i][j][k] = min\{f[i - 1][j][k], f[i - 1][max\{0, j - o2[i]\}][max\{0, k - n2[i]\}] + w[i]\}$

初始化：$f[0][0][0] = 0$，其余$f[i][j][k] = +\infin$

优化空间：去掉气瓶这一维，第二、三层倒序遍历，$f[j][k]$足以表示状态。

#### 时间复杂度

$O(k \times m \times n)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1010, V1 = 22, V2 = 80;

int f[V1][V2], n, v1, v2, c1[N], c2[N], w[N];

int main() {
    cin >> v1 >> v2 >> n;
    for (int i = 0; i < n; i++)
        cin >> c1[i] >> c2[i] >> w[i];
    for (int i = 0; i <= v1; i++)
        for (int j = 0; j <= v2; j++)
            f[i][j] = 0x3f3f3f3f;
    f[0][0] = 0;
    
    for (int i = 0; i < n; i++) {
        for (int j = v1; j >= 0; j--)
            for (int k = v2; k >= 0; k--)
                f[j][k] = min(f[j][k], f[max(0, j - c1[i])][max(0, k - c2[i])] + w[i]);
    }
    cout << f[v1][v2] << endl;
    return 0;
}
```