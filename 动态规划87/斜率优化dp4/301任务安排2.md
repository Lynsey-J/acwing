### 题目描述

有  N  个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。
机器会把这  N  个任务分成若干批，每一批包含连续的若干个任务。
从时刻  0  开始，任务被分批加工，执行第  i  个任务所需的时间是  Ti 。
另外，在每批任务开始前，机器需要  S  的启动时间，故执行一批任务所需的时间是启动时间  S  加上每个任务所需时间之和。
一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。
也就是说，同一批任务将在同一时刻完成。
每个任务的费用是它的完成时刻乘以一个费用系数  Ci 。
请为机器规划一个分组方案，使得总费用最小。

输入格式
第一行包含整数  N 。

第二行包含整数  S 。

接下来  N  行每行有一对整数，分别为  Ti  和  Ci ，表示第  i  个任务单独完成所需的时间  Ti  及其费用系数  Ci 。

输出格式
输出一个整数，表示最小总费用。

数据范围
1≤N≤3×10^5 ,
1≤Ti,Ci≤512 ,
0≤S≤512

### 样例

Input

```
5
1
1 3
3 2
4 3
2 3
1 4
```

Output

```
153
```

----------

### 算法
#### dp + 斜率优化

对$C_i, T_i$求前缀和得到前缀和数组$c[], t[]$

由`300任务安排1`得到的状态转移方程$f[i]=min\{f[j]+(c[i]−c[j]) \times t[i] + (c[n]−c[j]) \times s\}$,$0 \le j < i$进行等价变换得$f[i] = min\{f[j] - c[j] \times (t[i] + s) + c[i] \times t[i] + c[n] \times s\}$, $0 \le j < i$。对于某一特定的$i$而言，令常数$C = c[i] \times t[i] + c[n] \times s$。考虑与$j$有关的量，暂时忽略$min$符号且尽量令$f[i]$的系数为正，移项得

$f[j] = (t[i] + s) \times c[j] + f[i] - C$（式子1）。

对应于直线$y = (t[i] + s) \times x + f[i] - C$

再考虑原问题是求$f[i]$的最小值，对于某一特定的$i$而言，在式子1中，若要使$f[i]$最小，则应使式子1描述的直线穿过点集$\{(c[j], f[j]) | 0 \le j < i\}$中最靠“下”的点：可以对点集维护一个凸包，找到凸包中某一边界，它的斜率是大于$f[i] + s$的最小的那个。

由于在本题中

$1 \le T_i \le 512 => t[i] > 0$ 

$0 \le S \le 512 => t[i] + s > 0$（条件1）

$1 \le C_i \le 512 => c[]单调递增$（条件2)

故可以进行优化，维护一个队列，队列中存储点对，相邻点对之间的斜率是递增的。由于条件1，队头不满足条件的点对可以直接出队，以后必不会再用到；由于条件2，可以直接在队尾判断新加的点对$(c[i], f[i])$是否构成凸包的边界。

扩展：

- 1、如果$C_i$可以为非正数：平衡树？？
- 2、如果$T_i$可以为非正数：不能使用队头优化，要用二分。

注意**避开除法**！

中间过程有一些乘法可能爆int，简单起见最好用**long long**

注意向队列中添加新的点对时，斜率相同时**后添加的点优先级更高**！因为用后添加的点构成的边界可以包含之前的点。

#### 时间复杂度

$O(n)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 300010;

LL c[N], t[N], f[N];
int n, s, que[N], hh, tt;

int main() {
    scanf("%d%d", &n, &s);
    for (int i = 1; i <= n; i++) {
        scanf("%lld%lld", &t[i], &c[i]);
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    que[++tt] = 0;
    for (int i = 1; i <= n; i++) {
        int k = t[i] + s;
        while (hh < tt && (f[que[hh + 1]] - f[que[hh]])
            <= k * (c[que[hh + 1]] - c[que[hh]])) hh++;
        int j = que[hh];
        f[i] = f[j] - k * c[j] + t[i] * c[i] + s * c[n];
        while (hh < tt && (f[i] - f[que[tt]]) * (c[que[tt]] - c[que[tt - 1]])
            <= (f[que[tt]] - f[que[tt - 1]]) * (c[i] - c[que[tt]])) tt--; //注意，是<=
        que[++tt] = i;
    }
    printf("%lld\n", f[n]);
    return 0;
}
```