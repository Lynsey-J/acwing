### 题目描述

有  N  个任务排成一个序列在一台机器上等待执行，它们的顺序不得改变。
机器会把这  N  个任务分成若干批，每一批包含连续的若干个任务。
从时刻  0  开始，任务被分批加工，执行第  i  个任务所需的时间是  Ti 。
另外，在每批任务开始前，机器需要  S  的启动时间，故执行一批任务所需的时间是启动时间  S  加上每个任务所需时间之和。
一个任务执行后，将在机器中稍作等待，直至该批任务全部执行完毕。
也就是说，同一批任务将在同一时刻完成。
每个任务的费用是它的完成时刻乘以一个费用系数  Ci 。
请为机器规划一个分组方案，使得总费用最小。

输入格式
第一行包含整数  N 。
第二行包含整数  S 。

接下来  N  行每行有一对整数，分别为  Ti  和  Ci ，表示第  i  个任务单独完成所需的时间  Ti  及其费用系数  Ci 。

输出格式
输出一个整数，表示最小总费用。

数据范围
1≤N≤5000 ,
0≤S≤50 ,
1≤Ti,Ci≤100 

### 样例

Input

```
5
1
1 3
3 2
4 3
2 3
1 4
```

Output

```
153
```

----------

### 算法
#### 斜率优化dp

链接：https://www.acwing.com/solution/contesnt/13036/

暴力枚举MLE——空间复杂度$O(n^2)$、时间复杂度$O(n^3)$
状态表示：①集合:$f[i][j]$表示前$i$个任务分成$j$组的集合。②属性:最小费用
状态计算：$f[i][j] = min(f[k][j−1] + (j \times s +\sum_{1}^{t} t[i]) \times (\sum_{k  + 1}^{i}c[i]))$,~~` j−1≤k≤i`~~$j - 1 \le k < i$
最后一个不同点：最后一组，枚举最后一组的起点：可以分为前$k$个机器分为$j−1$组，$k+1 \sim i$个机器是第$j$组
$\sum_{1}^{i}t[i]$和$\sum_{i}^{k + 1}c[i]$可以用前缀和优化。

为什么要写暴力?
所有题目拿下来都可以先向暴力的方向去想，然后再进行优化

进一步思考
我们为什么要枚举每一组？是为了得到启动机器的次数进而算费用
我们可以发现，只要我们分一组，后面还未分组的机器一定会增加相应的费用，高兴的是我们现在就可以算出来增加的费用是多少，所以我们只需要提前把这个多出来的费用加上就行了
状态转移方程：$f[i]=min(f[j]+(c[i]−c[j]) \times t[i] + (c[n]−c[j]) \times s)$,$0 \le j < i$
同上$c[i]$和$t[i]$是前缀和。

但是这样计算出的中间结果不一定正确。=>状态$f[i]$表示的是将前$i$个任务分配好的费用+额外的启动时间对其余$n - i$个任务影响的最小值。


#### 时间复杂度

$O(n ^ 2)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 5010;

int f[N], t[N], c[N];
int n, s;

int main() {
    cin >> n >> s;
    for (int i = 1; i <= n; i++) {
        cin >> t[i] >> c[i];
        t[i] += t[i - 1];
        c[i] += c[i - 1];
    }
    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < i; j++)
            f[i] = min(f[i], f[j] + t[i] * (c[i] - c[j]) + s * (c[n] - c[j]));
    cout << f[n] << endl;
    return 0;
}
```