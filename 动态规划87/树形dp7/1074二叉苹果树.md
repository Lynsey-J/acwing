### 题目描述

有一棵二叉苹果树，如果树枝有分叉，一定是分两叉，即没有只有一个儿子的节点。
这棵树共  N  个节点，编号为  1  至  N ，树根编号一定为  1 。
我们用一根树枝两端连接的节点编号描述一根树枝的位置。
一棵苹果树的树枝太多了，需要剪枝。但是一些树枝上长有苹果，给定需要保留的树枝数量，求最多能留住多少苹果。
这里的保留是指最终与1号点连通。

输入格式
第一行包含两个整数  N  和  Q ，分别表示树的节点数以及要保留的树枝数量。
接下来  N−1  行描述树枝信息，每行三个整数，前两个是它连接的节点的编号，第三个数是这根树枝上苹果数量。

输出格式
输出仅一行，表示最多能留住的苹果的数量。

数据范围
1≤Q<N≤100 .
N≠1 ,
每根树枝上苹果不超过  30000  个。

### 样例

Input

```
5 2
1 3 1
1 4 10
2 3 20
3 5 20
```

Output

```
21
```

----------

### 算法
#### dp + 分组背包

注意用无向边表示树，边数是$2 \times (n - 1)$；无向图遍历时，在dfs的参数中记录父结点编号会更容易。

~~为了简化理解，把树枝上的苹果数放在箭头结点中，问题转化为除了根结点外，保留$Q$个结点（包括根结点保留$Q + 1$个结点）时，最多能留住多少个苹果。
预处理数组$apples[i]$表示~~以$i$为根结点的树中的苹果数量~~结点$i$的等价苹果数，$cnt[i]$表示以$i$为根结点的树中结点数量。
状态：$f[i][j]$表示以$i$为根结点的保留$j$个结点的树的最大保留苹果数。
转移：（关键在于这是一颗每个结点度为2的二叉树）$f[i][j] = max\{f[son1][k] + f[son2][j - 1 - k] + apples[i]\}, 0 \le k \le min(cnt[son1], j - 1)$, $1 \le j \le cnt[i]$
$f[i][0] = 0$
初始化：$f[i][0] = 0$, $f[i][1]$可通过转移求得。
答案：$f[1][q + 1]$~~

状态：$f[i][j]$表示以结点$i$为根的树，保留$j$条边的最大苹果树

转移：分组背包，先遍历物品组，再遍历背包容量，最后遍历物品组内的每一个物品。对于每个结点而言，有两个子结点，每个子结点相当于一个物品组，$f[son][k]$相当于物品。

答案：$f[1][q]$

``` cpp
/*对于结点u的子结点son, 边权为w（一个物品组）*/
for (int j = q; j; j--) //背包容量
	for (int k = 0; k < j; k++) //物品
    /*省略了一维
    f[u][i][j] = max(f[u][i][j], f[u][i - 1][j - k - 1] + f[son][i][k] + w);
    */
		f[u][j] = max(f[u][j], f[u][j - (k + 1)] + f[son][k] + w); //1 + k是代价，f[son][k] + w是价值
```

#### 时间复杂度

$O(n \times q ^ 2)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 110, M = 210;

int h[N], ne[M], va[M], we[M], idx;
int f[N][N], n, q;

void insert(int u, int v, int w) {
    ne[++idx] = h[u];
    va[idx] = v;
    we[idx] = w;
    h[u] = idx;
}

void dfs(int u, int pa) {
    for (int i = h[u]; i; i = ne[i]) {
        int v = va[i], w = we[i];
        if (pa == v) continue;
        dfs(v, u);
        for (int j = q; j; j--)
            for (int k = 0; k < j; k++)
                f[u][j] = max(f[u][j], f[u][j - 1 - k] + f[v][k] + w);
    }    
}

int main() {
    cin >> n >> q;
    for (int i = 1; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        insert(u, v, w);
        insert(v, u, w);
    }
    dfs(1, -1);
    cout << f[1][q] << endl;
    return 0;
}
```