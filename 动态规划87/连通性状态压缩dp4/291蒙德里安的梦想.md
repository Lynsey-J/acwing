### 题目描述

求把  N×M  的棋盘分割成若干个  1×2  的的长方形，有多少种方案。
例如当  N=2，M=4  时，共有  5  种方案。当  N=2，M=3  时，共有  3  种方案。
如下图所示：

2411_1.jpg

输入格式
输入包含多组测试用例。
每组测试用例占一行，包含两个整数  N  和  M 。
当输入用例  N=0，M=0  时，表示输入终止，且该用例无需处理。

输出格式
每个测试用例输出一个结果，每个结果占一行。

数据范围
1≤N,M≤11

### 样例

Input

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

Output

```
1
0
1
2
3
5
144
51205
```

----------

### 算法
#### 状态压缩dp

只考虑长方形竖向排布，当每行中未被竖向排布的长方形占据的连续格子数不为奇数时，则为一种合法方案。

~~状态：$f[i][j]$表示从第$i - 1$行伸向第$i$行的状态为$j$（用$j$的二进制数的每位表示对应位置是否伸出）的方案数。
转移：枚举从第$i - 2$行伸向第$i - 1$行的状态$k$，第$i - 1$行伸向第$i$行的状态$j$，$f[i][j] += f[i - 1][k]$（如果第$i$行的空格合法且$j, k$不冲突）
结果：枚举合法的$j$，$\sum f[n][j]$~~

状态：$f[i][j]$表示从第$i$行伸向第$i + 1$行的状态为$j$（用$j$的二进制数的每位表示对应位置是否伸出）的方案数。
转移：枚举从第$i - 1$行伸向第$i$行的状态$k$，第$i$行伸向第$i + 1$行的状态$j$，$f[i][j] += f[i - 1][k]$（如果第$i$行的空格合法且$j, k$不冲突）
结果：$f[n][0]$

预处理：
法一：为了加快判断某一状态是否合法（连续的空格是否为奇数），用$st$数组存储预处理结果，而不是在循环内判断。

法二：预处理哪两种状态$i$,$j$是可以组合的（更费空间？）

为了处理方便：$i$从1开始，$j$从0开始

根据样例会爆int。。

#### 时间复杂度

$O(n \times 2 ^ {2n})$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 12, V = (1 << 11) + 10;

LL f[N][V];
int n, m;
bool st[V];

int main() {
    while (scanf("%d%d", &n, &m), n) {
        for (int i = 0; i < 1 << m; i++) {
            st[i] = true;
            int cnt = 0;
            for (int j = 0; j <= m; j++)
                if (j == m || i >> j & 1) {
                    if (cnt & 1) {
                        st[i] = false;
                        break;
                    }
                    cnt = 0;
                } else cnt++;
        }
        memset(f, 0, sizeof f); //别忘了！
        f[0][0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 0; j < 1 << m; j++)
                for (int k = 0; k < 1 << m; k++)
                    if (!(j & k) && st[j | k]) //顺序对时间有影响，当前850ms，反过来1450ms
                        f[i][j] += f[i - 1][k];
        printf("%lld\n", f[n][0]);
    }
    return 0;
}
```