### 题目描述

Kiana 最近沉迷于一款神奇的游戏无法自拔。   
简单来说，这款游戏是在一个平面上进行的。 
有一架弹弓位于  (0,0)  处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟， 小鸟们的飞行轨迹均为形如  y=ax^2+bx  的曲线，其中  a,b  是 Kiana 指定的参数，且必须满足  a<0 。
当小鸟落回地面（即  x  轴）时，它就会瞬间消失。
在游戏的某个关卡里，平面的第一象限中有  n  只绿色的小猪，其中第  i  只小猪所在的坐标为  (xi,yi) 。 
如果某只小鸟的飞行轨迹经过了  (xi,yi) ，那么第  i  只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 
如果一只小鸟的飞行轨迹没有经过  (xi,yi) ，那么这只小鸟飞行的全过程就不会对第  i  只小猪产生任何影响。 
例如，若两只小猪分别位于  (1,3)  和  (3,3) ，Kiana 可以选择发射一只飞行轨迹为  y=−x2+4x  的小鸟，这样两只小猪就会被这只小鸟一起消灭。 
而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。 
这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个这个游戏。   
这些指令将在输入格式中详述。 
假设这款游戏一共有  T  个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。  
由于她不会算，所以希望由你告诉她。
注意:本题除 NOIP 原数据外，还包含加强数据。

输入格式
第一行包含一个正整数  T ，表示游戏的关卡总数。
下面依次输入这  T  个关卡的信息。
每个关卡第一行包含两个非负整数  n,m ，分别表示该关卡中的小猪数量和 Kiana 输入的神秘指令类型。
接下来的  n  行中，第  i  行包含两个正实数  (xi,yi) ，表示第  i  只小猪坐标为  (xi,yi) ，数据保证同一个关卡中不存在两只坐标完全相同的小猪。
如果  m=0 ，表示 Kiana 输入了一个没有任何作用的指令。
如果  m=1 ，则这个关卡将会满足：至多用  ⌈n/3+1⌉  只小鸟即可消灭所有小猪。
如果  m=2 ，则这个关卡将会满足：一定存在一种最优解，其中有一只小鸟消灭了至少  ⌊n/3⌋  只小猪。
保证  1≤n≤18，0≤m≤2，0<xi,yi<10 ，输入中的实数均保留到小数点后两位。
上文中，符号  ⌈c⌉  和  ⌊c⌋  分别表示对  c  向上取整和向下取整，例如 ： ⌈2.1⌉=⌈2.9⌉=⌈3.0⌉=⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3 。

输出格式
对每个关卡依次输出一行答案。
输出的每一行包含一个正整数，表示相应的关卡中，消灭所有小猪最少需要的小鸟数量。

数据范围
QQ截图20210311115727.png

### 样例

Input

```
2
2 0
1.00 3.00
3.00 3.00
5 2
1.00 5.00
2.00 8.00
3.00 9.00
4.00 8.00
5.00 5.00
```

Output

```
1
1
```

----------

### 算法一
#### dp

状态：$f[i]$表示击中与$i$中二进制展开为$1$的位对应的小猪所需的最小次数。

为了不给自己找麻烦，采用$f[i + 1] = function(f[i])$的形式，而不是$f[i] = function(f[i - 1])$的形式。

重点在于转移：当遍历到状态$i$时，$f[i]$若不为$+\infin$则一定是最优解。

这个方法中间结果貌似不一定对，比如：$f[2], f[4], f[8], f[6], f[12]$均为$+ \infin$（但因为要把所有小猪都打掉，先打哪只无所谓，故最终结果是正确的）

#### 时间复杂度

$O((n ^ 3n \times 2 ^ n) \times T)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

#define x first
#define y second

typedef pair<double, double> PDD;

const int N = 20, M = 1 << 18;
const double EPS = 1e-6;

int f[M], curve[N][N];
PDD point[N];

void pre(int n) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            curve[i][j] = 1 << i; //发射一次有可能只能击中一只小猪
            double x1 = point[i].x, y1 = point[i].y;
            double x2 = point[j].x, y2 = point[j].y;
            if (abs(x1 - x2) < EPS) continue; //x1 != x2
            double a = (y1 / x1 - y2 / x2) / (x1 - x2);
            double b = y1 / x1 - a * x1;
            if (a >= 0) continue; //a < 0
            for (int k = 0; k < n; k++) {
                double x3 = point[k].x, y3 = point[k].y;
                if (abs(a * x3 * x3 + b * x3 - y3) < EPS) {
                    curve[i][j] |= 1 << k;
                }
            }
        }
}

int main() {
    int T, n, m;
    cin >> T;
    while (T--) {
        cin >> n >> m;
        for (int i = 0; i < n; i++)
            cin >> point[i].x >> point[i].y;
        pre(n);
        memset(f, 0x3f, sizeof f);
        f[0] = 0;
        for (int i = 0; i + 1 < 1 << n; i++) {
            int x = -1;
            for (int j = 0; j < n; j++) {
                if (!(i >> j & 1)) {
                    x = j;
                    break;
                }
            }
            for (int j = 0; j < n; j++) {
                f[i | curve[x][j]] = min(f[i | curve[x][j]], f[i] + 1);
            }
        }
        cout << f[(1 << n) - 1] << endl;
    }
    return 0;
}
```

### 算法二
#### DancingLinks

最多有$n ^ 2$个不同的抛物线。接下来求出所有不同的抛物线，及其能覆盖的所有点的点集。
此时问题变成了经典的“重复覆盖问题”，即给定01矩阵，要求选择尽量少的行，将所有列覆盖住。这里标准做法是使用 Dancing Links。
https://www.acwing.com/solution/content/4028/