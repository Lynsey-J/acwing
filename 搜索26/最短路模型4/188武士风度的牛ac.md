### 题目描述

农民John有很多牛，他想交易其中一头被Don称为The Knight的牛。
这头牛有一个独一无二的超能力，在农场里像Knight一样地跳（就是我们熟悉的象棋中马的走法）。
虽然这头神奇的牛不能跳到树上和石头上，但是它可以在牧场上随意跳，我们把牧场用一个x，y的坐标图来表示。
这头神奇的牛像其它牛一样喜欢吃草，给你一张地图，上面标注了The Knight的开始位置，树、灌木、石头以及其它障碍的位置，除此之外还有一捆草。
现在你的任务是，确定The Knight要想吃到草，至少需要跳多少次。
The Knight的位置用’K’来标记，障碍的位置用’*’来标记，草的位置用’H’来标记。
这里有一个地图的例子：
             11 | . . . . . . . . . .
             10 | . . . . * . . . . . 
              9 | . . . . . . . . . . 
              8 | . . . * . * . . . . 
              7 | . . . . . . . * . . 
              6 | . . * . . * . . . H 
              5 | * . . . . . . . . . 
              4 | . . . * . . . * . . 
              3 | . K . . . . . . . . 
              2 | . . . * . . . . . * 
              1 | . . * . . . . * . . 
              0 ----------------------
                                    1 
                0 1 2 3 4 5 6 7 8 9 0 
The Knight 可以按照下图中的A,B,C,D…这条路径用5次跳到草的地方（有可能其它路线的长度也是5）：
             11 | . . . . . . . . . .
             10 | . . . . * . . . . .
              9 | . . . . . . . . . .
              8 | . . . * . * . . . .
              7 | . . . . . . . * . .
              6 | . . * . . * . . . F<
              5 | * . B . . . . . . .
              4 | . . . * C . . * E .
              3 | .>A . . . . D . . .
              2 | . . . * . . . . . *
              1 | . . * . . . . * . .
              0 ----------------------
                                    1
                0 1 2 3 4 5 6 7 8 9 0
注意： 数据保证一定有解。

输入格式
第1行： 两个数，表示农场的列数C(C<=150)和行数R(R<=150)。
第2..R+1行: 每行一个由C个字符组成的字符串，共同描绘出牧场地图。

输出格式
一个整数，表示跳跃的最小次数。

### 样例

Input

```
10 11
..........
....*.....
..........
...*.*....
.......*..
..*..*...H
*.........
...*...*..
.K........
...*.....*
..*....*..
```

Output

```
5
```

----------

### 算法
#### bfs最短路

图的联通方式为日字走而不是横竖走，其他一模一样。

注意先输入列数，再输入行数。

如果要过滤空格一个字符一个字符输入，可以用`cin`。

#### 时间复杂度

$O(n ^ 2)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

typedef pair<int, int> PII;

const int N = 155;

int n, m;
char maze[N][N];
int dx[8] = {1, -1, -2, -2, -1, 1, 2, 2}, dy[8] = {-2, -2, -1, 1, 2, 2, 1, -1};
int d[N][N];
PII que[N * N];
int hh, tt = -1;
PII K, H;

void bfs(int u, int v) {
    maze[u][v] = '*';
    que[++tt] = {u, v};
    while (hh <= tt) {
        int tu = que[hh].first, tv = que[hh].second;
        hh++;
        for (int i = 0; i < 8; i++) {
            int x = tu + dx[i], y = tv + dy[i];
            if (x < 0 || x >= n || y < 0 || y >= m) continue;
            if (maze[x][y] != '*') {
                que[++tt] = {x, y};
                maze[x][y] = '*';
                d[x][y] = d[tu][tv] + 1;
            }
        }
    }
}

int main() {
    cin >> m >> n;
    for (int i = 0; i < n; i++) {
        cin >> maze[i];
        for (int j = 0; j < m; j++)
            if (maze[i][j] == 'H') H = {i, j};
            else if (maze[i][j] == 'K') K = {i, j};
    }
    bfs(K.first, K.second);
    cout << d[H.first][H.second] << endl;
    return 0;
}
```