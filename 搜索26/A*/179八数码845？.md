### 题目描述

在一个3×3的网格中，1~8这8个数字和一个“X”恰好不重不漏地分布在这3×3的网格中。
例如：
1 2 3
X 4 6
7 5 8
在游戏过程中，可以把“X”与其上、下、左、右四个方向之一的数字交换（如果存在）。
我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：
1 2 3
4 5 6
7 8 X
例如，示例中图形就可以通过让“X”先后与右、下、右三个方向的数字交换成功得到正确排列。
交换过程如下：
1 2 3   1 2 3   1 2 3   1 2 3
X 4 6   4 X 6   4 5 6   4 5 6
7 5 8   7 5 8   7 X 8   7 8 X
把“X”与上下左右方向数字交换的行动记录为“u”、“d”、“l”、“r”。
现在，给你一个初始网格，请你通过最少的移动次数，得到正确排列。

输入格式
输入占一行，将3×3的初始网格描绘出来。
例如，如果初始网格如下所示：
1 2 3
x 4 6
7 5 8
则输入为：1 2 3 x 4 6 7 5 8
输出格式
输出占一行，包含一个字符串，表示得到正确排列的完整行动记录。如果答案不唯一，输出任意一种合法方案即可。
如果不存在解决方案，则输出”unsolvable”。

### 样例

Input

```
2  3  4  1  5  x  7  6  8
```

Output

```
ullddrurdllurdruldr
```

----------

### 算法
#### Astar

本题在`845八数码`的基础上求操作序列。

方法：第一次出队时结束。

做法：
bfs中的队列换成优先队列（小根堆），队列中存从起点$S$到当前点$state$的真实距离$d[state]$+ 从当前点$state$到终点$T$的估计距离$f(state)$，记当前点$state$到终点的真实距离为$g(state)$，那么$0 \le f(state) \le g(state)$，$f,g$越接近越好（当估值是0时，形式上类似于Dijkstra算法，证明不一样）.

证明（反证法）：
假设终点第一次出堆时不是最小值，那么意味着$d[T] > d[T]_{最优}$，堆中存在最优路径中的某个点（起码起点在路径上），记该点为$u$，$d[T]_{最优} = d[u] + g(u) \ge d[u] + f(u)$ -> $d[T] > d[T]_{最优} \ge d[u] + f(u)$，这说明优先队列中存在一个比出堆元素更小的元素，矛盾，所以终点第一次出堆时一定最优。

应用条件：
1.问题有解（无解时，仍然会把所有空间搜索，且比一般的bfs慢，因为优先队列每次操作是$O(logn)$的）
2.边权非负，如果是负数，那么估值有可能取负数，终点可能会提前出堆。

性质：
除了终点以外的其他点无法在出堆或者入堆的时候确定距离，只能保证终点出堆时是最优的。提高课视频2.1.3，1:05:00
    
总结：
BFS：每个结点入队一次，入队求出最优解，Dijkstra：出队求出，Astar：只有终点出队时可以求出。

八数码有解的充要条件：逆序对为偶数。必要性证明：每次移动不改变逆序对数奇偶性。充分性：证明相当复杂。

估价函数怎么取：当前状态每个数字和它目标位置的曼哈顿距离之和。

#### 时间复杂度

$O(n)$

#### 参考文献

#### C++ 代码

``` cpp

```