### 题目描述

一天Extense在森林里探险的时候不小心走入了一个迷宫，迷宫可以看成是由  n∗n  的格点组成，每个格点只有2种状态，.和#，前者表示可以通行后者表示不能通行。
同时当Extense处在某个格点时，他只能移动到东南西北(或者说上下左右)四个方向之一的相邻格点上，Extense想要从点A走到点B，问在不走出迷宫的情况下能不能办到。
如果起点或者终点有一个不能通行(为#)，则看成无法办到。
注意：A、B不一定是两个不同的点。

输入格式
第1行是测试数据的组数  k ，后面跟着  k  组输入。
每组测试数据的第1行是一个正整数  n ，表示迷宫的规模是  n∗n  的。
接下来是一个  n∗n  的矩阵，矩阵中的元素为.或者#。
再接下来一行是 4 个整数  ha,la,hb,lb ，描述  A  处在第  ha  行, 第  la  列， B  处在第  hb  行, 第  lb  列。
注意到  ha,la,hb,lb  全部是从 0 开始计数的。

输出格式
k行，每行输出对应一个输入。
能办到则输出“YES”，否则输出“NO”。

数据范围
1≤n≤100

### 样例

Input

```
2
3
.##
..#
#..
0 0 2 2
5
.....
###.#
..#..
###..
...#.
0 0 4 0
```

Output

```
YES
NO
```

----------

### 算法1
#### (暴力枚举)

注意起点，终点可能为‘#’，起点终点可能是一个点。

#### 时间复杂度

$O(n ^ 2)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 105;

char maze[N][N];
int n, x1, y1, x2, y2;
int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};

bool dfs(int x, int y) {
    if (x == x2 && y == y2) return true;
    maze[x][y] = '#';
    for (int i = 0; i < 4; i++) {
        int tx = x + dx[i], ty = y + dy[i];
        if (tx < 0 || tx >= n || ty < 0 || ty >= n) continue;
        if (maze[tx][ty] == '#') continue;
        if (dfs(tx, ty)) return true;
    }
    return false;
}

int main() {
    int cases;
    cin >> cases;
    while (cases--) {
        cin >> n;
        for (int i = 0; i < n; i++)
            cin >> maze[i];
        cin >> x1 >> y1 >> x2 >> y2;
        if (maze[x1][y1] == '#') puts("NO");
        else if (dfs(x1, y1)) puts("YES");
        else puts("NO");
    }
    return 0;
}
```