### 题目描述

    1   2   3   4   5   6   7  
   #############################
 1  #       |     #      |     #     |     |       #
   #####---#####---#---#####---#
 2 #   #   |   #   #   #   #   #
   #---#####---#####---#####---#
 3 #   |   |   #   #   #   #   #
   #---#########---#####---#---#
 4 #   #   |   |   |   |   #   #
   #############################
           (图 1)

   #  = Wall   
   |  = No wall
   -  = No wall

   方向：上北下南左西右东。
图1是一个城堡的地形图。
请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。
城堡被分割成  m∗n 个方格区域，每个方格区域可以有0~4面墙。
注意：墙体厚度忽略不计。

输入格式
第一行包含两个整数  m  和  n ，分别表示城堡南北方向的长度和东西方向的长度。
接下来  m  行，每行包含  n  个整数，每个整数都表示平面图对应位置的方块的墙的特征。
每个方块中墙的特征由数字  P  来描述，我们用1表示西墙，2表示北墙，4表示东墙，8表示南墙， P  为该方块包含墙的数字之和。
例如，如果一个方块的  P  为3，则 3 = 1 + 2，该方块包含西墙和北墙。
城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。
输入的数据保证城堡至少有两个房间。

输出格式
共两行，第一行输出房间总数，第二行输出最大房间的面积（方块数）。

数据范围
1≤m,n≤50 ,
0≤P≤15

### 样例

Input

```
4 7 
11 6 11 6 3 10 6 
7 9 6 13 5 15 5 
1 10 12 7 13 7 5 
13 11 10 8 10 12 13 
```

Output

```
5
9
```

----------

### 算法
#### 暴力搜索

每遍历一个点增加一个计数。Flood Fill。
`dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0}; //西北东南`

注意行列坐标别搞混，`if (!st[x][y])`和`if (!st[u][v])`别搞混。

#### 时间复杂度

$O(n^2)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 50;

int wall[N][N];
bool st[N][N];
int n, m;

int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};

void dfs(int u, int v, int &si) {
    st[u][v] = true;
    si++;
    for (int i = 0; i < 4; i++) {
        if (wall[u][v] >> i & 1) continue;
        int x = u + dx[i], y = v + dy[i];
        if (x < 0 || x >= n || y < 0 || y >= m) continue;
        if (!st[x][y]) dfs(x, y, si);
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> wall[i][j];
    int res = 0, cnt = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            if (!st[i][j]) {
                cnt++;
                int si = 0;
                dfs(i, j, si);
                res = max(res, si);
            }
    cout << cnt << endl << res << endl;
    return 0;
}
```