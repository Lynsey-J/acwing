### 题目描述

给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

输入格式
第一行包含整数n。
第二行包含n个整数（均在0~100000范围内），表示整数序列。

输出格式
共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。

数据范围
1≤n≤100000

### 样例

Input

```
5
1 2 2 3 5
```

Output

```
3
```

----------

### 算法
#### 双指针算法

~~单调队列？？~~：队列里的元素是单调的。

先考虑暴力算法，设序列存在数组$a$中，先看以$a[0]$为首的最长连续不重复子序列，再依次看以$a[1]$,$a[2]$,...,$a[n - 2]$为首的最长连续不重复子序列。若$a[0] \sim a[x]$不重复，长度为$x + 1$，$a[0] \sim a[x + 1]$重复，则$a[1] \sim a[x]$, ..., $a[x - 1] \sim a[x]$有可能与$a[x + 1]$及其后面的元素构成更长的连续不重复子序列。故接下来考虑以$a[1], a[2], ... , a[x]$中哪个为首是合法的。

初始：指针$i = 0$，指针$j = 0$。

然后移动指针到$i = x + 1$，每次移动$j$一格，直到$a[j] \sim a[i]$不重复，这样的$j$是合法的。

#### 时间复杂度

$O(n)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 100010;

int a[N], cnt[N];

int main() {
    int n, res = 0;
    cin >> n;
    for (int i = 0, j = 0; i < n; i++) {
        cin >> a[i];
        cnt[a[i]]++;
        while (cnt[a[i]] > 1) cnt[a[j++]]--;
        res = max(res, i - j + 1);
    }
    cout << res << endl;
    return 0;
}
```