### 题目描述

给定两个升序排序的有序数组A和B，以及一个目标值x。数组下标从0开始。
请你求出满足A[i] + B[j] = x的数对(i, j)。
数据保证有唯一解。

输入格式
第一行包含三个整数n，m，x，分别表示A的长度，B的长度以及目标值x。
第二行包含n个整数，表示数组A。
第三行包含m个整数，表示数组B。

输出格式
共一行，包含两个整数 i 和 j。

数据范围
数组长度不超过100000。
同一数组内元素各不相同。
1≤数组元素≤10^9

### 样例

Input

```
4 5 6
1 2 4 7
3 4 6 8 9
```

Output

```
1 1
```

----------

### 算法
#### 双指针算法

“在利用双指针算法解题时，考虑原问题如何用暴力算法解出，观察是否可构成单调性，若可以就可采用双指针算法对
暴力算法进行优化”

初始：$i$指向$A[0]$，$j$指向$B[m - 1]$

猜测：若$A[i] + B[j] > x$，则$j--$；若$A[i] + B[j] < x$，则$i++$。

证明：先考虑暴力算法，然后优化。若$A[0]$和$B[m - 1]$,$B[m - 2]$,...,$B[m - x + 1]$的组合都>0,和$A[m - x]$组合<0，那么$A[1]$，$A[2]$, ... , $A[n - 1]$和$B[m - 1]$,$B[m - 2]$,...,$B[m - x + 1]$的组合一定>0。从此以后只需要考虑$A[1]$，$A[2]$, ... , $A[n - 1]$和$B[m - x]$,$B[m - x - 1]$, ... , $B[0]$的组合。类推，可以让问题规模减小。


#### 时间复杂度

$O(n)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 100010;

int a[N], b[N];

int main() {
    int n, m, x;
    cin >> n >> m >> x;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int j = 0; j < m; j++) cin >> b[j];
    int i = 0, j = m - 1;
    while (true) {
        if (a[i] + b[j] == x) break;
        else if (a[i] + b[j] > x) j--;
        else i++;
    }
    cout << i << ' ' << j << endl;
    return 0;
}
```