### 题目描述

农民约翰的 N头奶牛（编号为 1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。
奶牛们不是非常有创意，只提出了一个杂技表演：
叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。
奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。
这 N头奶牛中的每一头都有着自己的重量 Wi，以及自己的强壮程度 Si。
一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。
您的任务是确定奶牛的排序，使得所有奶牛的风险值中的**最大值尽可能的小**。

输入格式

第一行输入整数 N，表示奶牛数量。
接下来 N行，每行输入两个整数，表示牛的重量和强壮程度，第 i行表示第 i头牛的重量 Wi以及它的强壮程度 Si。

输出格式
输出一个整数，表示最大风险值的最小可能值。

数据范围
1≤N≤50000,
1≤Wi≤10,000,
1≤Si≤1,000,000,000

### 样例

Input

```
3
10 3
2 5
3 3
```

Output

```
2
```

----------

### 算法
#### 贪心的微扰（邻项交换）

https://www.acwing.com/solution/content/845/

天上蹦出一个做法：按照$s + w$排序。

设编号为$1$的牛在最顶上。

证明：

首先，交换两头牛对除这两头牛外的其他牛的危险值不构成影响。

考虑相邻的两头牛$i, i + 1$。

|牛编号|交换前危险值|交换后危险值|
|:----:|:----:|:----:|
| i | $\sum\limits_{j = 0}^{i - 1}\{w_j\} - s_i$ | $\sum\limits_{j = 0}^{i - 1}\{w_j\} + w_{i + 1} - s_i$ |
| i + 1 | $\sum\limits_{j = 0}^{i}\{w_j\} - s_{i + 1}$ | $\sum\limits_{j = 0}^{i - 1}\{w_j\} - s_{i + 1}$ |

同时减去$\sum\limits_{j = 0}^{i - 1}\{w_j\}$得：

|牛编号|交换前危险值|交换后危险值|
|:----:|:----:|:----:|
| i | $-s_i$ | $w_{i + 1} - s_i$ |
| i + 1 | $w_i - s_{i + 1}$ | $-s_{i + 1}$ |

由于$w_i > 0$，第$i$头牛交换后危险值变大，第$i + 1$头牛交换后危险值变小。

- 当$-s_i < w_i - s_{i + 1}$时，且满足$w_{i + 1} - s_i < w_i - s_{i + 1}$即$w_{i + 1} + s_{i + 1} < w_i + s_i$时，交换才有效果。
- 当$-s_i >= w_i - s_{i + 1}$时，交换肯定没有效果。。

总结：

- $w_{i + 1} + s_{i + 1} < w_i + s_i$时，应当交换
- $s_{i + 1} < w_i + s_i \le w_{i + 1} + s_{i + 1}$时，不应交换
- $s_{i + 1} >= w_i + s_i$时，不应交换

故按$s + w$升序排列时，一定不用交换就可以达到最优效果。

#### 时间复杂度

$O(nlogn)$

#### 参考文献

#### C++ 代码

``` cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 500010;

int n, sum;
PII a[N];

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        int w, s;
        scanf("%d%d", &w, &s);
        a[i] = {w + s, w};
    }
    sort(a + 1, a + 1 + n);
    int res = -0x3f3f3f3f; //注意危险值可能为负数
    for (int i = 1; i <= n; i++) {
        int w = a[i].second, s = a[i].first - w;
        res = max(res, sum - s);
        sum += w;
    }
    printf("%d\n", res);
    return 0;
}
```